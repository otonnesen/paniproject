# Implementation Details
- Scalable hashing/routing service
	- hash: 6 digit alphanumeric [a-z0-9]
	- bijection: [1,~2 billion] <-> 6 digit strings from [a-z0-9]
		- just convert from base 10 to base 36 and expand
	- we can get way more links by adding more letters to choose (ie. A-Z), or length
- Database to synchronize hash/routing workers
	- one table, three columns: id (auto increment) / original url / hash (string)

# Core Features
- Hashing (url -> shortened url)
- Routing (accessing shortened url redirects to original url)
- Conflict avoidance (insert linked url to db before returning its assigned hash)

# Potential Additional Features
- Custom back-half
	- Optional parameter in api, return error if already taken
	- Idea: Adding back-half happens after link creation, and the custom back-half is sort of tacked on (cf. bitly api)
	- Another idea: force custom back-halfs to begin with a capital letter to avoid conflict with auto generated back-halfs
- Analytics?
- Permute ids so we don't just get the sequence 'aaaaaa', 'aaaaab', etc.
	- Can be super simple, just find a number coprime with 36^6 (6^12 = 2^12*3^12 by the way) and multiply id by that
		- A power of any prime other than 2 or 3 works, just try different ones until the output looks reasonable 'random'

# Simplifying Assumptions
- I'll use localhost instead of trying to figure out domain routing
- Optimizing database accesses between containers is out of scope, so I'll ignore anything problematic that comes up

# To do
[ ] Hashing
	- Go program
[ ] Routing
	- Go program (same one?)
[ ] Database
	- little sqlite3 thing
	- schema
